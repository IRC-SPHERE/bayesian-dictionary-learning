// <auto-generated />
#pragma warning disable 1570, 1591

using System;
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Collections;
using MicrosoftResearch.Infer.Factors;

namespace MicrosoftResearch.Infer.Models.User
{
	/// <summary>
	/// Generated algorithm for performing inference.
	/// </summary>
	/// <remarks>
	/// If you wish to use this class directly, you must perform the following steps:
	/// 1) Create an instance of the class.
	/// 2) Set the value of any externally-set fields e.g. data, priors.
	/// 3) Call the Execute(numberOfIterations) method.
	/// 4) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
	/// 
	/// Generated by Infer.NET 2.6.41114.1 at 21:32 on 14 May 2016.
	/// </remarks>
	public partial class BayesianDictionaryLearning_VMP : IGeneratedAlgorithm
	{
		#region Fields
		/// <summary>Field backing the NumberOfIterationsDone property</summary>
		private int numberOfIterationsDone;
		/// <summary>Field backing the numberOfBases property</summary>
		private int NumberOfBases;
		/// <summary>Field backing the numberOfSignals property</summary>
		private int NumberOfSignals;
		/// <summary>Field backing the signalWidth property</summary>
		private int SignalWidth;
		/// <summary>Field backing the a property</summary>
		private double A;
		/// <summary>Field backing the b property</summary>
		private double B;
		/// <summary>Field backing the noisePrecisionPrior property</summary>
		private Gamma NoisePrecisionPrior;
		/// <summary>Field backing the dictionaryPriors property</summary>
		private Gaussian[,] DictionaryPriors;
		/// <summary>Field backing the signals property</summary>
		private double[,] Signals;
		/// <summary>Field backing the missing property</summary>
		private bool[,] Missing;
		/// <summary>Field backing the vdouble20 property</summary>
		private double Vdouble20;
		/// <summary>The number of iterations last computed by Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0. Set this to zero to force re-execution of Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0</summary>
		public int Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone;
		/// <summary>The number of iterations last computed by Constant. Set this to zero to force re-execution of Constant</summary>
		public int Constant_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals_numberOfBases. Set this to zero to force re-execution of Changed_numberOfSignals_numberOfBases</summary>
		public int Changed_numberOfSignals_numberOfBases_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3. Set this to zero to force re-execution of Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3</summary>
		public int Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone;
		/// <summary>True if Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3 has performed initialisation. Set this to false to force re-execution of Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3</summary>
		public bool Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals. Set this to zero to force re-execution of Changed_numberOfSignals</summary>
		public int Changed_numberOfSignals_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals_signalWidth. Set this to zero to force re-execution of Changed_numberOfSignals_signalWidth</summary>
		public int Changed_numberOfSignals_signalWidth_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals_signalWidth_missing_numberOfBases. Set this to zero to force re-execution of Changed_numberOfSignals_signalWidth_missing_numberOfBases</summary>
		public int Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7. Set this to zero to force re-execution of Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7</summary>
		public int Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone;
		/// <summary>True if Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7 has performed initialisation. Set this to false to force re-execution of Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7</summary>
		public bool Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised;
		/// <summary>The number of iterations last computed by Changed_numberOfBases_signalWidth. Set this to zero to force re-execution of Changed_numberOfBases_signalWidth</summary>
		public int Changed_numberOfBases_signalWidth_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9. Set this to zero to force re-execution of Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9</summary>
		public int Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone;
		/// <summary>True if Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9 has performed initialisation. Set this to false to force re-execution of Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9</summary>
		public bool Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised;
		/// <summary>The number of iterations last computed by Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10. Set this to zero to force re-execution of Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10</summary>
		public int Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_iterationsDone;
		/// <summary>True if Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10 has performed initialisation. Set this to false to force re-execution of Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10</summary>
		public bool Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised;
		/// <summary>Message from use of 'noisePrecision'</summary>
		public Gamma noisePrecision_use_B;
		public DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> products_B;
		/// <summary>Message from use of 'coefficientPrecisions'</summary>
		public DistributionStructArray2D<Gamma,double> coefficientPrecisions_use_B;
		/// <summary>Message from use of 'coefficients'</summary>
		public DistributionStructArray2D<Gaussian,double> coefficients_use_B;
		/// <summary>Message to marginal of 'dictionary'</summary>
		public DistributionStructArray2D<Gaussian,double> dictionary_marginal_F;
		/// <summary>Message to marginal of 'coefficients'</summary>
		public DistributionStructArray2D<Gaussian,double> coefficients_marginal_F;
		/// <summary>Message to marginal of 'noisePrecision'</summary>
		public Gamma noisePrecision_marginal_F;
		/// <summary>Message to marginal of 'evidence'</summary>
		public Bernoulli evidence_marginal_F;
		#endregion

		#region Properties
		/// <summary>The number of iterations done from the initial state</summary>
		public int NumberOfIterationsDone
		{
			get {
				return this.numberOfIterationsDone;
			}
		}

		/// <summary>The externally-specified value of 'numberOfBases'</summary>
		public int numberOfBases
		{
			get {
				return this.NumberOfBases;
			}
			set {
				if (this.NumberOfBases!=value) {
					this.NumberOfBases = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 0;
					this.Changed_numberOfBases_signalWidth_iterationsDone = 0;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone = 0;
					this.Changed_numberOfSignals_numberOfBases_iterationsDone = 0;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone = 0;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'numberOfSignals'</summary>
		public int numberOfSignals
		{
			get {
				return this.NumberOfSignals;
			}
			set {
				if (this.NumberOfSignals!=value) {
					this.NumberOfSignals = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 0;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
					this.Changed_numberOfSignals_numberOfBases_iterationsDone = 0;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone = 0;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'signalWidth'</summary>
		public int signalWidth
		{
			get {
				return this.SignalWidth;
			}
			set {
				if (this.SignalWidth!=value) {
					this.SignalWidth = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 0;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 0;
					this.Changed_numberOfBases_signalWidth_iterationsDone = 0;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone = 0;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'a'</summary>
		public double a
		{
			get {
				return this.A;
			}
			set {
				if (this.A!=value) {
					this.A = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'b'</summary>
		public double b
		{
			get {
				return this.B;
			}
			set {
				if (this.B!=value) {
					this.B = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'noisePrecisionPrior'</summary>
		public Gamma noisePrecisionPrior
		{
			get {
				return this.NoisePrecisionPrior;
			}
			set {
				if (this.NoisePrecisionPrior!=value) {
					this.NoisePrecisionPrior = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'dictionaryPriors'</summary>
		public Gaussian[,] dictionaryPriors
		{
			get {
				return this.DictionaryPriors;
			}
			set {
				if ((value!=null)&&(((value.GetLength(0))!=this.NumberOfBases)||((value.GetLength(1))!=this.SignalWidth))) {
					throw new ArgumentException(((("Provided array of size "+(((("("+(value.GetLength(0)))+",")+(value.GetLength(1)))+")"))+" when size ")+(((("("+this.NumberOfBases)+",")+this.SignalWidth)+")"))+" was expected");
				}
				this.DictionaryPriors = value;
				this.numberOfIterationsDone = 0;
				this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
				this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
				this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone = 0;
				this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'signals'</summary>
		public double[,] signals
		{
			get {
				return this.Signals;
			}
			set {
				if ((value!=null)&&(((value.GetLength(0))!=this.NumberOfSignals)||((value.GetLength(1))!=this.SignalWidth))) {
					throw new ArgumentException(((("Provided array of size "+(((("("+(value.GetLength(0)))+",")+(value.GetLength(1)))+")"))+" when size ")+(((("("+this.NumberOfSignals)+",")+this.SignalWidth)+")"))+" was expected");
				}
				this.Signals = value;
				this.numberOfIterationsDone = 0;
				this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
				this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
				this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
				this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'missing'</summary>
		public bool[,] missing
		{
			get {
				return this.Missing;
			}
			set {
				if ((value!=null)&&(((value.GetLength(0))!=this.NumberOfSignals)||((value.GetLength(1))!=this.SignalWidth))) {
					throw new ArgumentException(((("Provided array of size "+(((("("+(value.GetLength(0)))+",")+(value.GetLength(1)))+")"))+" when size ")+(((("("+this.NumberOfSignals)+",")+this.SignalWidth)+")"))+" was expected");
				}
				this.Missing = value;
				this.numberOfIterationsDone = 0;
				this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
				this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 0;
				this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 0;
				this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
				this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'vdouble20'</summary>
		public double vdouble20
		{
			get {
				return this.Vdouble20;
			}
			set {
				if (this.Vdouble20!=value) {
					this.Vdouble20 = value;
					this.numberOfIterationsDone = 0;
					this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
					this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
					this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
					this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
				}
			}
		}

		#endregion

		#region Methods
		/// <summary>Get the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object GetObservedValue(string variableName)
		{
			if (variableName=="numberOfBases") {
				return this.numberOfBases;
			}
			if (variableName=="numberOfSignals") {
				return this.numberOfSignals;
			}
			if (variableName=="signalWidth") {
				return this.signalWidth;
			}
			if (variableName=="a") {
				return this.a;
			}
			if (variableName=="b") {
				return this.b;
			}
			if (variableName=="noisePrecisionPrior") {
				return this.noisePrecisionPrior;
			}
			if (variableName=="dictionaryPriors") {
				return this.dictionaryPriors;
			}
			if (variableName=="signals") {
				return this.signals;
			}
			if (variableName=="missing") {
				return this.missing;
			}
			if (variableName=="vdouble20") {
				return this.vdouble20;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>Set the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		/// <param name="value">Observed value</param>
		public void SetObservedValue(string variableName, object value)
		{
			if (variableName=="numberOfBases") {
				this.numberOfBases = (int)value;
				return ;
			}
			if (variableName=="numberOfSignals") {
				this.numberOfSignals = (int)value;
				return ;
			}
			if (variableName=="signalWidth") {
				this.signalWidth = (int)value;
				return ;
			}
			if (variableName=="a") {
				this.a = (double)value;
				return ;
			}
			if (variableName=="b") {
				this.b = (double)value;
				return ;
			}
			if (variableName=="noisePrecisionPrior") {
				this.noisePrecisionPrior = (Gamma)value;
				return ;
			}
			if (variableName=="dictionaryPriors") {
				this.dictionaryPriors = (Gaussian[,])value;
				return ;
			}
			if (variableName=="signals") {
				this.signals = (double[,])value;
				return ;
			}
			if (variableName=="missing") {
				this.missing = (bool[,])value;
				return ;
			}
			if (variableName=="vdouble20") {
				this.vdouble20 = (double)value;
				return ;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>Get the marginal distribution (computed up to this point) of a variable</summary>
		/// <param name="variableName">Name of the variable in the generated code</param>
		/// <returns>The marginal distribution computed up to this point</returns>
		/// <remarks>Execute, Update, or Reset must be called first to set the value of the marginal.</remarks>
		public object Marginal(string variableName)
		{
			if (variableName=="evidence") {
				return this.EvidenceMarginal();
			}
			if (variableName=="noisePrecision") {
				return this.NoisePrecisionMarginal();
			}
			if (variableName=="coefficients") {
				return this.CoefficientsMarginal();
			}
			throw new ArgumentException("This class was not built to infer "+variableName);
		}

		/// <summary>Get the marginal distribution (computed up to this point) of a variable, converted to type T</summary>
		/// <typeparam name="T">The distribution type.</typeparam>
		/// <param name="variableName">Name of the variable in the generated code</param>
		/// <returns>The marginal distribution computed up to this point</returns>
		/// <remarks>Execute, Update, or Reset must be called first to set the value of the marginal.</remarks>
		public T Marginal<T>(string variableName)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName));
		}

		/// <summary>Get the query-specific marginal distribution of a variable.</summary>
		/// <param name="variableName">Name of the variable in the generated code</param>
		/// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
		/// <remarks>Execute, Update, or Reset must be called first to set the value of the marginal.</remarks>
		public object Marginal(string variableName, string query)
		{
			if (query=="Marginal") {
				return this.Marginal(variableName);
			}
			throw new ArgumentException(((("This class was not built to infer \'"+variableName)+"\' with query \'")+query)+"\'");
		}

		/// <summary>Get the query-specific marginal distribution of a variable, converted to type T</summary>
		/// <typeparam name="T">The distribution type.</typeparam>
		/// <param name="variableName">Name of the variable in the generated code</param>
		/// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
		/// <remarks>Execute, Update, or Reset must be called first to set the value of the marginal.</remarks>
		public T Marginal<T>(string variableName, string query)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName, query));
		}

		/// <summary>Update all marginals, by iterating message passing the given number of times</summary>
		/// <param name="numberOfIterations">The number of times to iterate each loop</param>
		/// <param name="initialise">If true, messages that initialise loops are reset when observed values change</param>
		private void Execute(int numberOfIterations, bool initialise)
		{
			if (numberOfIterations<this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone) {
				this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = false;
				this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = false;
				this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = false;
				this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
			}
			this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10(initialise);
			this.Changed_numberOfSignals();
			this.Changed_numberOfSignals_signalWidth();
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases();
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7(initialise);
			this.Constant();
			this.Changed_numberOfBases_signalWidth();
			this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9(initialise);
			this.Changed_numberOfSignals_numberOfBases();
			this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3(initialise);
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0(numberOfIterations);
			this.numberOfIterationsDone = numberOfIterations;
		}

		/// <summary>Update all marginals, by iterating message-passing the given number of times</summary>
		/// <param name="numberOfIterations">The total number of iterations that should be executed for the current set of observed values.  If this is more than the number already done, only the extra iterations are done.  If this is less than the number already done, message-passing is restarted from the beginning.  Changing the observed values resets the iteration count to 0.</param>
		public void Execute(int numberOfIterations)
		{
			this.Execute(numberOfIterations, true);
		}

		/// <summary>Update all marginals, by iterating message-passing an additional number of times</summary>
		/// <param name="additionalIterations">The number of iterations that should be executed, starting from the current message state.  Messages are not reset, even if observed values have changed.</param>
		public void Update(int additionalIterations)
		{
			this.Execute(this.numberOfIterationsDone+additionalIterations, false);
		}

		private void OnProgressChanged(ProgressChangedEventArgs e)
		{
			// Make a temporary copy of the event to avoid a race condition
			// if the last subscriber unsubscribes immediately after the null check and before the event is raised.
			EventHandler<ProgressChangedEventArgs> handler = this.ProgressChanged;
			if (handler!=null) {
				handler(this, e);
			}
		}

		/// <summary>Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0.</summary>
		public void Reset()
		{
			this.Execute(0);
		}

		/// <summary>Computations that must reset on changes to numberOfIterationsDecreased and numberOfSignals and signalWidth and missing and numberOfBases and signals and noisePrecisionPrior and dictionaryPriors and a and b and vdouble20</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		private void Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10(bool initialise)
		{
			if ((this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_iterationsDone==1)&&((!initialise)||this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised)) {
				return ;
			}
			this.noisePrecision_use_B = Gamma.Uniform();
			this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_iterationsDone = 1;
			this.Init_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noisePrec10_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals</summary>
		private void Changed_numberOfSignals()
		{
			if (this.Changed_numberOfSignals_iterationsDone==1) {
				return ;
			}
			// Create array for replicates of 'products_B'
			this.products_B = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.NumberOfSignals);
			this.Changed_numberOfSignals_iterationsDone = 1;
			this.Changed_numberOfSignals_signalWidth_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals and signalWidth</summary>
		private void Changed_numberOfSignals_signalWidth()
		{
			if (this.Changed_numberOfSignals_signalWidth_iterationsDone==1) {
				return ;
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'products_B'
				this.products_B[signal] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.SignalWidth);
			}
			this.Changed_numberOfSignals_signalWidth_iterationsDone = 1;
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals and signalWidth and missing and numberOfBases</summary>
		private void Changed_numberOfSignals_signalWidth_missing_numberOfBases()
		{
			if (this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone==1) {
				return ;
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						// Create array for 'products' Backwards messages.
						this.products_B[signal][sample] = new DistributionStructArray<Gaussian,double>(this.NumberOfBases);
					}
				}
			}
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_iterationsDone = 1;
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals and signalWidth and missing and numberOfBases and must reset on changes to numberOfIterationsDecreased and signals and noisePrecisionPrior and dictionaryPriors and a and b and vdouble20</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		private void Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7(bool initialise)
		{
			if ((this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone==1)&&((!initialise)||this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised)) {
				return ;
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							this.products_B[signal][sample][basis] = Gaussian.Uniform();
						}
					}
				}
			}
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_iterationsDone = 1;
			this.Changed_numberOfSignals_signalWidth_missing_numberOfBases_Init_numberOfIterationsDecreased_signals_n7_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
		}

		/// <summary>Computations that do not depend on observed values</summary>
		private void Constant()
		{
			if (this.Constant_iterationsDone==1) {
				return ;
			}
			this.Constant_iterationsDone = 1;
			this.Changed_numberOfSignals_numberOfBases_iterationsDone = 0;
			this.Changed_numberOfBases_signalWidth_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfBases and signalWidth</summary>
		private void Changed_numberOfBases_signalWidth()
		{
			if (this.Changed_numberOfBases_signalWidth_iterationsDone==1) {
				return ;
			}
			// Create array for 'dictionary_marginal' Forwards messages.
			this.dictionary_marginal_F = new DistributionStructArray2D<Gaussian,double>(this.NumberOfBases, this.SignalWidth);
			this.Changed_numberOfBases_signalWidth_iterationsDone = 1;
			this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfBases and signalWidth and dictionaryPriors and must reset on changes to numberOfIterationsDecreased and numberOfSignals and missing and signals and noisePrecisionPrior and a and b and vdouble20</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		private void Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9(bool initialise)
		{
			if ((this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone==1)&&((!initialise)||this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised)) {
				return ;
			}
			for(int basis = 0; basis<this.NumberOfBases; basis++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					this.dictionary_marginal_F[basis, sample] = ArrayHelper.MakeCopy<Gaussian>(this.DictionaryPriors[basis, sample]);
				}
			}
			this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_iterationsDone = 1;
			this.Changed_numberOfBases_signalWidth_dictionaryPriors_Init_numberOfIterationsDecreased_numberOfSignals_9_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals and numberOfBases</summary>
		private void Changed_numberOfSignals_numberOfBases()
		{
			if (this.Changed_numberOfSignals_numberOfBases_iterationsDone==1) {
				return ;
			}
			// Create array for 'coefficientPrecisions_use' Backwards messages.
			this.coefficientPrecisions_use_B = new DistributionStructArray2D<Gamma,double>(this.NumberOfSignals, this.NumberOfBases);
			// Create array for 'coefficients_use' Backwards messages.
			this.coefficients_use_B = new DistributionStructArray2D<Gaussian,double>(this.NumberOfSignals, this.NumberOfBases);
			this.Changed_numberOfSignals_numberOfBases_iterationsDone = 1;
			this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfSignals and numberOfBases and must reset on changes to numberOfIterationsDecreased and signalWidth and missing and signals and noisePrecisionPrior and dictionaryPriors and a and b and vdouble20</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		private void Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3(bool initialise)
		{
			if ((this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone==1)&&((!initialise)||this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised)) {
				return ;
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					this.coefficientPrecisions_use_B[signal, basis] = Gamma.Uniform();
					this.coefficients_use_B[signal, basis] = Gaussian.Uniform();
				}
			}
			this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_iterationsDone = 1;
			this.Changed_numberOfSignals_numberOfBases_Init_numberOfIterationsDecreased_signalWidth_missing_signals_n3_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfIterationsDecreased and numberOfSignals and signalWidth and missing and numberOfBases and signals and noisePrecisionPrior and dictionaryPriors and a and b and vdouble20</summary>
		/// <param name="numberOfIterations">The number of times to iterate each loop</param>
		private void Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0(int numberOfIterations)
		{
			if (this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone==numberOfIterations) {
				return ;
			}
			// Create array for replicates of 'clean_signal_sample_0__F'
			DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> clean_signal_sample_0__F = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'clean_signal_sample_0__F'
				clean_signal_sample_0__F[signal] = new DistributionStructArray<Gaussian,double>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (this.Missing[signal, sample]) {
						clean_signal_sample_0__F[signal][sample] = Gaussian.Uniform();
					}
				}
			}
			Gaussian _hoist2 = default(Gaussian);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (this.Missing[signal, sample]) {
						_hoist2 = ArrayHelper.CopyStorage<Gaussian>(clean_signal_sample_0__F[signal][sample]);
						signal = this.NumberOfSignals-1;
						sample = this.SignalWidth-1;
					}
				}
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (this.Missing[signal, sample]) {
						_hoist2 = Distribution.SetPoint<Gaussian,double>(_hoist2, Factor.Copy<double>(this.Vdouble20));
						signal = this.NumberOfSignals-1;
						sample = this.SignalWidth-1;
					}
				}
			}
			DistributionStructArray2D<Gaussian,double> clean_F = default(DistributionStructArray2D<Gaussian,double>);
			// Create array for 'clean' Forwards messages.
			clean_F = new DistributionStructArray2D<Gaussian,double>(this.NumberOfSignals, this.SignalWidth);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					clean_F[signal, sample] = Gaussian.Uniform();
					if (this.Missing[signal, sample]) {
						// Message to 'clean' from Copy factor
						clean_F[signal, sample] = ArrayHelper.SetTo<Gaussian>(clean_F[signal, sample], _hoist2);
					}
				}
			}
			Gamma _hoist = default(Gamma);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					_hoist = Gamma.Uniform();
					signal = this.NumberOfSignals-1;
					basis = this.NumberOfBases-1;
				}
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					_hoist = GammaFromShapeAndRateOpBase.SampleAverageLogarithm(this.A, this.B);
					signal = this.NumberOfSignals-1;
					basis = this.NumberOfBases-1;
				}
			}
			// Message to marginal of 'coefficientPrecisions'
			DistributionStructArray2D<Gamma,double> coefficientPrecisions_marginal_F = default(DistributionStructArray2D<Gamma,double>);
			// Create array for 'coefficientPrecisions_marginal' Forwards messages.
			coefficientPrecisions_marginal_F = new DistributionStructArray2D<Gamma,double>(this.NumberOfSignals, this.NumberOfBases);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					coefficientPrecisions_marginal_F[signal, basis] = Gamma.Uniform();
				}
			}
			DistributionStructArray2D<Gaussian,double> coefficients_F = default(DistributionStructArray2D<Gaussian,double>);
			// Create array for 'coefficients' Forwards messages.
			coefficients_F = new DistributionStructArray2D<Gaussian,double>(this.NumberOfSignals, this.NumberOfBases);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					coefficients_F[signal, basis] = Gaussian.Uniform();
				}
			}
			DistributionStructArray2D<Gaussian,double> clean_B = default(DistributionStructArray2D<Gaussian,double>);
			// Create array for 'clean' Backwards messages.
			clean_B = new DistributionStructArray2D<Gaussian,double>(this.NumberOfSignals, this.SignalWidth);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					clean_B[signal, sample] = Gaussian.Uniform();
				}
			}
			// Create array for replicates of 'coefficients_signal_basis_1__B'
			DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> coefficients_signal_basis_1__B = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'coefficients_signal_basis_1__B'
				coefficients_signal_basis_1__B[signal] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						// Create array for 'coefficients_signal_basis_1_' Backwards messages.
						coefficients_signal_basis_1__B[signal][sample] = new DistributionStructArray<Gaussian,double>(this.NumberOfBases);
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							coefficients_signal_basis_1__B[signal][sample][basis] = Gaussian.Uniform();
						}
					}
				}
			}
			// Create array for replicates of 'coefficients_rep_B'
			DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> coefficients_rep_B = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'coefficients_rep_B'
				coefficients_rep_B[signal] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.NumberOfBases);
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Create array for 'coefficients_rep' Backwards messages.
					coefficients_rep_B[signal][basis] = new DistributionStructArray<Gaussian,double>(this.SignalWidth);
					for(int sample = 0; sample<this.SignalWidth; sample++) {
						coefficients_rep_B[signal][basis][sample] = Gaussian.Uniform();
					}
				}
			}
			// Create array for 'coefficients_marginal' Forwards messages.
			this.coefficients_marginal_F = new DistributionStructArray2D<Gaussian,double>(this.NumberOfSignals, this.NumberOfBases);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					this.coefficients_marginal_F[signal, basis] = Gaussian.Uniform();
				}
			}
			// Create array for replicates of 'dictionary_basis_sample_1__B'
			DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> dictionary_basis_sample_1__B = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'dictionary_basis_sample_1__B'
				dictionary_basis_sample_1__B[signal] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						// Create array for 'dictionary_basis_sample_1_' Backwards messages.
						dictionary_basis_sample_1__B[signal][sample] = new DistributionStructArray<Gaussian,double>(this.NumberOfBases);
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							dictionary_basis_sample_1__B[signal][sample][basis] = Gaussian.Uniform();
						}
					}
				}
			}
			// Create array for replicates of 'dictionary_rep_B'
			DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> dictionary_rep_B = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.SignalWidth);
			for(int sample = 0; sample<this.SignalWidth; sample++) {
				// Create array for replicates of 'dictionary_rep_B'
				dictionary_rep_B[sample] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.NumberOfBases);
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Create array for 'dictionary_rep' Backwards messages.
					dictionary_rep_B[sample][basis] = new DistributionStructArray<Gaussian,double>(this.NumberOfSignals);
				}
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					for(int basis = 0; basis<this.NumberOfBases; basis++) {
						dictionary_rep_B[sample][basis][signal] = Gaussian.Uniform();
					}
				}
			}
			// Message from use of 'dictionary'
			DistributionStructArray2D<Gaussian,double> dictionary_use_B = default(DistributionStructArray2D<Gaussian,double>);
			// Create array for 'dictionary_use' Backwards messages.
			dictionary_use_B = new DistributionStructArray2D<Gaussian,double>(this.NumberOfBases, this.SignalWidth);
			for(int basis = 0; basis<this.NumberOfBases; basis++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					dictionary_use_B[basis, sample] = Gaussian.Uniform();
				}
			}
			// Create array for replicates of 'products_F'
			DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]> products_F = new DistributionRefArray<DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>,double[][]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'products_F'
				products_F[signal] = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						// Create array for 'products' Forwards messages.
						products_F[signal][sample] = new DistributionStructArray<Gaussian,double>(this.NumberOfBases);
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							products_F[signal][sample][basis] = Gaussian.Uniform();
						}
					}
				}
			}
			// Create array for replicates of 'clean_signal_sample_1__F'
			DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> clean_signal_sample_1__F = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for replicates of 'clean_signal_sample_1__F'
				clean_signal_sample_1__F[signal] = new DistributionStructArray<Gaussian,double>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						clean_signal_sample_1__F[signal][sample] = Gaussian.Uniform();
					}
				}
			}
			// Create array for replicates of 'noisePrecision_rep_rep_B'
			DistributionRefArray<DistributionStructArray<Gamma,double>,double[]> noisePrecision_rep_rep_B = new DistributionRefArray<DistributionStructArray<Gamma,double>,double[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'noisePrecision_rep_rep' Backwards messages.
				noisePrecision_rep_rep_B[signal] = new DistributionStructArray<Gamma,double>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					noisePrecision_rep_rep_B[signal][sample] = Gamma.Uniform();
				}
			}
			DistributionStructArray<Gamma,double> noisePrecision_rep_B = default(DistributionStructArray<Gamma,double>);
			// Create array for 'noisePrecision_rep' Backwards messages.
			noisePrecision_rep_B = new DistributionStructArray<Gamma,double>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				noisePrecision_rep_B[signal] = Gamma.Uniform();
			}
			this.noisePrecision_marginal_F = Gamma.Uniform();
			// Message to 'noisePrecision_marginal' from Variable factor
			this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(this.noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Message to 'coefficientPrecisions_marginal' from Variable factor
					coefficientPrecisions_marginal_F[signal, basis] = VariableVmpOp.MarginalAverageLogarithm<Gamma>(this.coefficientPrecisions_use_B[signal, basis], _hoist, coefficientPrecisions_marginal_F[signal, basis]);
					// Message to 'coefficients' from Gaussian factor
					coefficients_F[signal, basis] = GaussianOp.SampleAverageLogarithm(0.0, coefficientPrecisions_marginal_F[signal, basis]);
					// Message to 'coefficients_marginal' from Variable factor
					this.coefficients_marginal_F[signal, basis] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(this.coefficients_use_B[signal, basis], coefficients_F[signal, basis], this.coefficients_marginal_F[signal, basis]);
					for(int sample = 0; sample<this.SignalWidth; sample++) {
						if (!this.Missing[signal, sample]) {
							// Message to 'products' from Product factor
							products_F[signal][sample][basis] = GaussianProductVmpOp.ProductAverageLogarithm(this.dictionary_marginal_F[basis, sample], this.coefficients_marginal_F[signal, basis]);
						}
					}
				}
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					// Message to 'clean' from Gaussian factor
					clean_B[signal, sample] = GaussianOp.MeanAverageLogarithm(this.Signals[signal, sample], this.noisePrecision_marginal_F);
					if (!this.Missing[signal, sample]) {
						// Message to 'products' from Sum factor
						this.products_B[signal][sample] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(clean_B[signal, sample], products_F[signal][sample], this.products_B[signal][sample]);
					}
				}
			}
			for(int iteration = this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone; iteration<numberOfIterations; iteration++) {
				for(int signal = 0; signal<this.NumberOfSignals; signal++) {
					for(int sample = 0; sample<this.SignalWidth; sample++) {
						if (!this.Missing[signal, sample]) {
							for(int basis = 0; basis<this.NumberOfBases; basis++) {
								// Message to 'coefficients_signal_basis_1_' from Product factor
								coefficients_signal_basis_1__B[signal][sample][basis] = GaussianProductVmpOp.BAverageLogarithm(this.products_B[signal][sample][basis], this.dictionary_marginal_F[basis, sample]);
								// Message to 'coefficients_rep' from Copy factor
								coefficients_rep_B[signal][basis][sample] = ArrayHelper.SetTo<Gaussian>(coefficients_rep_B[signal][basis][sample], coefficients_signal_basis_1__B[signal][sample][basis]);
							}
						}
					}
					for(int basis = 0; basis<this.NumberOfBases; basis++) {
						// Message to 'coefficients_use' from Replicate factor
						this.coefficients_use_B[signal, basis] = ReplicateOp.DefAverageLogarithm<Gaussian>(coefficients_rep_B[signal][basis], this.coefficients_use_B[signal, basis]);
						// Message to 'coefficientPrecisions_marginal' from Variable factor
						coefficientPrecisions_marginal_F[signal, basis] = VariableVmpOp.MarginalAverageLogarithm<Gamma>(this.coefficientPrecisions_use_B[signal, basis], _hoist, coefficientPrecisions_marginal_F[signal, basis]);
						// Message to 'coefficients' from Gaussian factor
						coefficients_F[signal, basis] = GaussianOp.SampleAverageLogarithm(0.0, coefficientPrecisions_marginal_F[signal, basis]);
						// Message to 'coefficients_marginal' from Variable factor
						this.coefficients_marginal_F[signal, basis] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(this.coefficients_use_B[signal, basis], coefficients_F[signal, basis], this.coefficients_marginal_F[signal, basis]);
						for(int sample = 0; sample<this.SignalWidth; sample++) {
							if (!this.Missing[signal, sample]) {
								// Message to 'products' from Product factor
								products_F[signal][sample][basis] = GaussianProductVmpOp.ProductAverageLogarithm(this.dictionary_marginal_F[basis, sample], this.coefficients_marginal_F[signal, basis]);
							}
						}
					}
					for(int sample = 0; sample<this.SignalWidth; sample++) {
						if (!this.Missing[signal, sample]) {
							// Message to 'clean_signal_sample_1_' from Sum factor
							clean_signal_sample_1__F[signal][sample] = FastSumOp.SumAverageLogarithm(products_F[signal][sample]);
							// Message to 'clean' from Copy factor
							clean_F[signal, sample] = ArrayHelper.SetTo<Gaussian>(clean_F[signal, sample], clean_signal_sample_1__F[signal][sample]);
						}
						// FactorManager.Any(clean_F[signal, sample], clean_F[signal, sample]) is now updated in all contexts
						// Message to 'noisePrecision_rep_rep' from Gaussian factor
						noisePrecision_rep_rep_B[signal][sample] = GaussianOp.PrecisionAverageLogarithm(this.Signals[signal, sample], clean_F[signal, sample]);
					}
					// Message to 'noisePrecision_rep' from Replicate factor
					noisePrecision_rep_B[signal] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep_rep_B[signal], noisePrecision_rep_B[signal]);
				}
				// Message to 'noisePrecision_use' from Replicate factor
				this.noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep_B, this.noisePrecision_use_B);
				// Message to 'noisePrecision_marginal' from Variable factor
				this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(this.noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
				for(int signal = 0; signal<this.NumberOfSignals; signal++) {
					for(int sample = 0; sample<this.SignalWidth; sample++) {
						// Message to 'clean' from Gaussian factor
						clean_B[signal, sample] = GaussianOp.MeanAverageLogarithm(this.Signals[signal, sample], this.noisePrecision_marginal_F);
						if (!this.Missing[signal, sample]) {
							// Message to 'products' from Sum factor
							this.products_B[signal][sample] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(clean_B[signal, sample], products_F[signal][sample], this.products_B[signal][sample]);
							for(int basis = 0; basis<this.NumberOfBases; basis++) {
								// Message to 'dictionary_basis_sample_1_' from Product factor
								dictionary_basis_sample_1__B[signal][sample][basis] = GaussianProductVmpOp.AAverageLogarithm(this.products_B[signal][sample][basis], this.coefficients_marginal_F[signal, basis]);
								// Message to 'dictionary_rep' from Copy factor
								dictionary_rep_B[sample][basis][signal] = ArrayHelper.SetTo<Gaussian>(dictionary_rep_B[sample][basis][signal], dictionary_basis_sample_1__B[signal][sample][basis]);
							}
						}
					}
				}
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					for(int basis = 0; basis<this.NumberOfBases; basis++) {
						// Message to 'dictionary_use' from Replicate factor
						dictionary_use_B[basis, sample] = ReplicateOp.DefAverageLogarithm<Gaussian>(dictionary_rep_B[sample][basis], dictionary_use_B[basis, sample]);
						// Message to 'dictionary_marginal' from Variable factor
						this.dictionary_marginal_F[basis, sample] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(dictionary_use_B[basis, sample], this.DictionaryPriors[basis, sample], this.dictionary_marginal_F[basis, sample]);
					}
				}
				for(int signal = 0; signal<this.NumberOfSignals; signal++) {
					for(int basis = 0; basis<this.NumberOfBases; basis++) {
						// Message to 'coefficientPrecisions_use' from Gaussian factor
						this.coefficientPrecisions_use_B[signal, basis] = GaussianOp.PrecisionAverageLogarithm(this.coefficients_marginal_F[signal, basis], 0.0);
					}
				}
				this.OnProgressChanged(new ProgressChangedEventArgs(iteration));
			}
			// The constant 'vBernoulli0'
			Bernoulli vBernoulli0 = Bernoulli.Uniform();
			this.evidence_marginal_F = Bernoulli.Uniform();
			Bernoulli[] evidence_selector_cases_0_uses_B = default(Bernoulli[]);
			// Create array for 'evidence_selector_cases_0_uses' Backwards messages.
			evidence_selector_cases_0_uses_B = new Bernoulli[32];
			for(int _ind = 0; _ind<32; _ind++) {
				evidence_selector_cases_0_uses_B[_ind] = Bernoulli.Uniform();
			}
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					if (!this.Missing[signal, sample]) {
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							// Message to 'products' from Product factor
							products_F[signal][sample][basis] = GaussianProductVmpOp.ProductAverageLogarithm(this.dictionary_marginal_F[basis, sample], this.coefficients_marginal_F[signal, basis]);
						}
						// Message to 'clean_signal_sample_1_' from Sum factor
						clean_signal_sample_1__F[signal][sample] = FastSumOp.SumAverageLogarithm(products_F[signal][sample]);
						// Message to 'clean' from Copy factor
						clean_F[signal, sample] = ArrayHelper.SetTo<Gaussian>(clean_F[signal, sample], clean_signal_sample_1__F[signal][sample]);
					}
					// FactorManager.Any(clean_F[signal, sample], clean_F[signal, sample]) is now updated in all contexts
					// Message to 'noisePrecision_rep_rep' from Gaussian factor
					noisePrecision_rep_rep_B[signal][sample] = GaussianOp.PrecisionAverageLogarithm(this.Signals[signal, sample], clean_F[signal, sample]);
				}
				// Message to 'noisePrecision_rep' from Replicate factor
				noisePrecision_rep_B[signal] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep_rep_B[signal], noisePrecision_rep_B[signal]);
			}
			// Message to 'noisePrecision_use' from Replicate factor
			this.noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep_B, this.noisePrecision_use_B);
			// Message to 'noisePrecision_marginal' from Variable factor
			this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(this.noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					// Message to 'clean' from Gaussian factor
					clean_B[signal, sample] = GaussianOp.MeanAverageLogarithm(this.Signals[signal, sample], this.noisePrecision_marginal_F);
					if (!this.Missing[signal, sample]) {
						// Message to 'products' from Sum factor
						this.products_B[signal][sample] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(clean_B[signal, sample], products_F[signal][sample], this.products_B[signal][sample]);
						for(int basis = 0; basis<this.NumberOfBases; basis++) {
							// Message to 'coefficients_signal_basis_1_' from Product factor
							coefficients_signal_basis_1__B[signal][sample][basis] = GaussianProductVmpOp.BAverageLogarithm(this.products_B[signal][sample][basis], this.dictionary_marginal_F[basis, sample]);
							// Message to 'coefficients_rep' from Copy factor
							coefficients_rep_B[signal][basis][sample] = ArrayHelper.SetTo<Gaussian>(coefficients_rep_B[signal][basis][sample], coefficients_signal_basis_1__B[signal][sample][basis]);
						}
					}
				}
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Message to 'coefficients_use' from Replicate factor
					this.coefficients_use_B[signal, basis] = ReplicateOp.DefAverageLogarithm<Gaussian>(coefficients_rep_B[signal][basis], this.coefficients_use_B[signal, basis]);
					// Message to 'coefficients_marginal' from Variable factor
					this.coefficients_marginal_F[signal, basis] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(this.coefficients_use_B[signal, basis], coefficients_F[signal, basis], this.coefficients_marginal_F[signal, basis]);
				}
			}
			// Message to 'evidence_selector_cases_0_uses' from Random factor
			evidence_selector_cases_0_uses_B[3] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F, this.NoisePrecisionPrior));
			// Message to 'evidence_selector_cases_0_uses' from Variable factor
			evidence_selector_cases_0_uses_B[4] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F));
			// Create array for replicates of 'evidence_selector_cases_0_rep_rep_uses_B'
			DistributionStructArray<Bernoulli,bool>[][] evidence_selector_cases_0_rep_rep_uses_B = new DistributionStructArray<Bernoulli,bool>[this.NumberOfBases][];
			for(int basis = 0; basis<this.NumberOfBases; basis++) {
				// Create array for 'evidence_selector_cases_0_rep_rep_uses' Backwards messages.
				evidence_selector_cases_0_rep_rep_uses_B[basis] = new DistributionStructArray<Bernoulli,bool>[this.SignalWidth];
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					// Create array for 'evidence_selector_cases_0_rep_rep_uses' Backwards messages.
					evidence_selector_cases_0_rep_rep_uses_B[basis][sample] = new DistributionStructArray<Bernoulli,bool>(2);
					for(int _ind = 0; _ind<2; _ind++) {
						evidence_selector_cases_0_rep_rep_uses_B[basis][sample][_ind] = Bernoulli.Uniform();
					}
					// Message to 'evidence_selector_cases_0_rep_rep_uses' from Random factor
					evidence_selector_cases_0_rep_rep_uses_B[basis][sample][0] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gaussian>(this.dictionary_marginal_F[basis, sample], this.DictionaryPriors[basis, sample]));
					// Message to 'evidence_selector_cases_0_rep_rep_uses' from Variable factor
					evidence_selector_cases_0_rep_rep_uses_B[basis][sample][1] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gaussian>(this.dictionary_marginal_F[basis, sample]));
				}
			}
			// Create array for replicates of 'evidence_selector_cases_0_rep_rep_B'
			DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]> evidence_selector_cases_0_rep_rep_B = new DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]>(this.NumberOfBases);
			for(int basis = 0; basis<this.NumberOfBases; basis++) {
				// Create array for 'evidence_selector_cases_0_rep_rep' Backwards messages.
				evidence_selector_cases_0_rep_rep_B[basis] = new DistributionStructArray<Bernoulli,bool>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					evidence_selector_cases_0_rep_rep_B[basis][sample] = Bernoulli.Uniform();
					// Message to 'evidence_selector_cases_0_rep_rep' from Replicate factor
					evidence_selector_cases_0_rep_rep_B[basis][sample] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep_rep_uses_B[basis][sample], evidence_selector_cases_0_rep_rep_B[basis][sample]);
				}
			}
			DistributionStructArray<Bernoulli,bool> evidence_selector_cases_0_rep_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'evidence_selector_cases_0_rep' Backwards messages.
			evidence_selector_cases_0_rep_B = new DistributionStructArray<Bernoulli,bool>(this.NumberOfBases);
			for(int basis = 0; basis<this.NumberOfBases; basis++) {
				evidence_selector_cases_0_rep_B[basis] = Bernoulli.Uniform();
				// Message to 'evidence_selector_cases_0_rep' from Replicate factor
				evidence_selector_cases_0_rep_B[basis] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep_rep_B[basis], evidence_selector_cases_0_rep_B[basis]);
			}
			// Message to 'evidence_selector_cases_0_uses' from Replicate factor
			evidence_selector_cases_0_uses_B[8] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep_B, evidence_selector_cases_0_uses_B[8]);
			// Create array for replicates of 'evidence_selector_cases_0_rep2_rep_uses_B'
			DistributionStructArray<Bernoulli,bool>[][] evidence_selector_cases_0_rep2_rep_uses_B = new DistributionStructArray<Bernoulli,bool>[this.NumberOfSignals][];
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'evidence_selector_cases_0_rep2_rep_uses' Backwards messages.
				evidence_selector_cases_0_rep2_rep_uses_B[signal] = new DistributionStructArray<Bernoulli,bool>[this.NumberOfBases];
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Create array for 'evidence_selector_cases_0_rep2_rep_uses' Backwards messages.
					evidence_selector_cases_0_rep2_rep_uses_B[signal][basis] = new DistributionStructArray<Bernoulli,bool>(2);
					for(int _ind = 0; _ind<2; _ind++) {
						evidence_selector_cases_0_rep2_rep_uses_B[signal][basis][_ind] = Bernoulli.Uniform();
					}
					// Message to 'evidence_selector_cases_0_rep2_rep_uses' from GammaFromShapeAndRate factor
					evidence_selector_cases_0_rep2_rep_uses_B[signal][basis][0] = Bernoulli.FromLogOdds(GammaFromShapeAndRateOpBase.AverageLogFactor(coefficientPrecisions_marginal_F[signal, basis], this.A, this.B));
					// Message to 'evidence_selector_cases_0_rep2_rep_uses' from Variable factor
					evidence_selector_cases_0_rep2_rep_uses_B[signal][basis][1] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(coefficientPrecisions_marginal_F[signal, basis]));
				}
			}
			// Create array for replicates of 'evidence_selector_cases_0_rep2_rep_B'
			DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]> evidence_selector_cases_0_rep2_rep_B = new DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'evidence_selector_cases_0_rep2_rep' Backwards messages.
				evidence_selector_cases_0_rep2_rep_B[signal] = new DistributionStructArray<Bernoulli,bool>(this.NumberOfBases);
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					evidence_selector_cases_0_rep2_rep_B[signal][basis] = Bernoulli.Uniform();
					// Message to 'evidence_selector_cases_0_rep2_rep' from Replicate factor
					evidence_selector_cases_0_rep2_rep_B[signal][basis] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep2_rep_uses_B[signal][basis], evidence_selector_cases_0_rep2_rep_B[signal][basis]);
				}
			}
			DistributionStructArray<Bernoulli,bool> evidence_selector_cases_0_rep2_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'evidence_selector_cases_0_rep2' Backwards messages.
			evidence_selector_cases_0_rep2_B = new DistributionStructArray<Bernoulli,bool>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				evidence_selector_cases_0_rep2_B[signal] = Bernoulli.Uniform();
				// Message to 'evidence_selector_cases_0_rep2' from Replicate factor
				evidence_selector_cases_0_rep2_B[signal] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep2_rep_B[signal], evidence_selector_cases_0_rep2_B[signal]);
			}
			// Message to 'evidence_selector_cases_0_uses' from Replicate factor
			evidence_selector_cases_0_uses_B[11] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep2_B, evidence_selector_cases_0_uses_B[11]);
			// Create array for replicates of 'evidence_selector_cases_0_rep3_rep_uses_B'
			DistributionStructArray<Bernoulli,bool>[][] evidence_selector_cases_0_rep3_rep_uses_B = new DistributionStructArray<Bernoulli,bool>[this.NumberOfSignals][];
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'evidence_selector_cases_0_rep3_rep_uses' Backwards messages.
				evidence_selector_cases_0_rep3_rep_uses_B[signal] = new DistributionStructArray<Bernoulli,bool>[this.NumberOfBases];
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					// Create array for 'evidence_selector_cases_0_rep3_rep_uses' Backwards messages.
					evidence_selector_cases_0_rep3_rep_uses_B[signal][basis] = new DistributionStructArray<Bernoulli,bool>(2);
					for(int _ind = 0; _ind<2; _ind++) {
						evidence_selector_cases_0_rep3_rep_uses_B[signal][basis][_ind] = Bernoulli.Uniform();
					}
					// Message to 'evidence_selector_cases_0_rep3_rep_uses' from Gaussian factor
					evidence_selector_cases_0_rep3_rep_uses_B[signal][basis][0] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.coefficients_marginal_F[signal, basis], 0.0, coefficientPrecisions_marginal_F[signal, basis]));
					// Message to 'evidence_selector_cases_0_rep3_rep_uses' from Variable factor
					evidence_selector_cases_0_rep3_rep_uses_B[signal][basis][1] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gaussian>(this.coefficients_marginal_F[signal, basis]));
				}
			}
			// Create array for replicates of 'evidence_selector_cases_0_rep3_rep_B'
			DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]> evidence_selector_cases_0_rep3_rep_B = new DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'evidence_selector_cases_0_rep3_rep' Backwards messages.
				evidence_selector_cases_0_rep3_rep_B[signal] = new DistributionStructArray<Bernoulli,bool>(this.NumberOfBases);
				for(int basis = 0; basis<this.NumberOfBases; basis++) {
					evidence_selector_cases_0_rep3_rep_B[signal][basis] = Bernoulli.Uniform();
					// Message to 'evidence_selector_cases_0_rep3_rep' from Replicate factor
					evidence_selector_cases_0_rep3_rep_B[signal][basis] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep3_rep_uses_B[signal][basis], evidence_selector_cases_0_rep3_rep_B[signal][basis]);
				}
			}
			DistributionStructArray<Bernoulli,bool> evidence_selector_cases_0_rep3_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'evidence_selector_cases_0_rep3' Backwards messages.
			evidence_selector_cases_0_rep3_B = new DistributionStructArray<Bernoulli,bool>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				evidence_selector_cases_0_rep3_B[signal] = Bernoulli.Uniform();
				// Message to 'evidence_selector_cases_0_rep3' from Replicate factor
				evidence_selector_cases_0_rep3_B[signal] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep3_rep_B[signal], evidence_selector_cases_0_rep3_B[signal]);
			}
			// Message to 'evidence_selector_cases_0_uses' from Replicate factor
			evidence_selector_cases_0_uses_B[14] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep3_B, evidence_selector_cases_0_uses_B[14]);
			// Create array for replicates of 'evidence_selector_cases_0_rep14_rep_B'
			DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]> evidence_selector_cases_0_rep14_rep_B = new DistributionRefArray<DistributionStructArray<Bernoulli,bool>,bool[]>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				// Create array for 'evidence_selector_cases_0_rep14_rep' Backwards messages.
				evidence_selector_cases_0_rep14_rep_B[signal] = new DistributionStructArray<Bernoulli,bool>(this.SignalWidth);
				for(int sample = 0; sample<this.SignalWidth; sample++) {
					evidence_selector_cases_0_rep14_rep_B[signal][sample] = Bernoulli.Uniform();
					// Message to 'evidence_selector_cases_0_rep14_rep' from Gaussian factor
					evidence_selector_cases_0_rep14_rep_B[signal][sample] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.Signals[signal, sample], clean_F[signal, sample], this.noisePrecision_marginal_F));
				}
			}
			DistributionStructArray<Bernoulli,bool> evidence_selector_cases_0_rep14_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'evidence_selector_cases_0_rep14' Backwards messages.
			evidence_selector_cases_0_rep14_B = new DistributionStructArray<Bernoulli,bool>(this.NumberOfSignals);
			for(int signal = 0; signal<this.NumberOfSignals; signal++) {
				evidence_selector_cases_0_rep14_B[signal] = Bernoulli.Uniform();
				// Message to 'evidence_selector_cases_0_rep14' from Replicate factor
				evidence_selector_cases_0_rep14_B[signal] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep14_rep_B[signal], evidence_selector_cases_0_rep14_B[signal]);
			}
			// Message to 'evidence_selector_cases_0_uses' from Replicate factor
			evidence_selector_cases_0_uses_B[28] = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_rep14_B, evidence_selector_cases_0_uses_B[28]);
			Bernoulli evidence_selector_cases_0_B = Bernoulli.Uniform();
			// Message to 'evidence_selector_cases_0' from Replicate factor
			evidence_selector_cases_0_B = ReplicateOp.DefAverageLogarithm<Bernoulli>(evidence_selector_cases_0_uses_B, evidence_selector_cases_0_B);
			DistributionStructArray<Bernoulli,bool> evidence_selector_cases_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'evidence_selector_cases' Backwards messages.
			evidence_selector_cases_B = new DistributionStructArray<Bernoulli,bool>(2);
			for(int _ind0 = 0; _ind0<2; _ind0++) {
				evidence_selector_cases_B[_ind0] = Bernoulli.Uniform();
			}
			// Message to 'evidence_selector_cases' from Copy factor
			evidence_selector_cases_B[0] = ArrayHelper.SetTo<Bernoulli>(evidence_selector_cases_B[0], evidence_selector_cases_0_B);
			Bernoulli evidence_selector_B = Bernoulli.Uniform();
			// Message to 'evidence_selector' from Cases factor
			evidence_selector_B = CasesOp.BAverageLogarithm(evidence_selector_cases_B);
			// Message to 'evidence_marginal' from Variable factor
			this.evidence_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Bernoulli>(evidence_selector_B, vBernoulli0, this.evidence_marginal_F);
			this.Changed_numberOfIterationsDecreased_numberOfSignals_signalWidth_missing_numberOfBases_signals_noiseP0_iterationsDone = numberOfIterations;
		}

		/// <summary>
		/// Returns the marginal distribution for 'evidence' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Bernoulli EvidenceMarginal()
		{
			return this.evidence_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'noisePrecision' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Gamma NoisePrecisionMarginal()
		{
			return this.noisePrecision_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'coefficients' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray2D<Gaussian,double> CoefficientsMarginal()
		{
			return this.coefficients_marginal_F;
		}

		#endregion

		#region Events
		/// <summary>Event that is fired when the progress of inference changes, typically at the end of one iteration of the inference algorithm.</summary>
		public event EventHandler<ProgressChangedEventArgs> ProgressChanged;
		#endregion

	}

}
